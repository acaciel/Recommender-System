# -*- coding: utf-8 -*-
"""Recommender System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xbsw0B-FjMJ_RIdsbVOOgm6Z44kOINpt

## Packages/Library yang Digunakan
"""

# --- Library utama ---
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics.pairwise import cosine_similarity
import ipywidgets as widgets
from IPython.display import display
import seaborn as sns
import matplotlib.pyplot as plt

"""## Data Understanding

### Load Dataset & Data Understanding

Dataset Top Spotify songs from 2010-2019-BY YEAR diambil dari Google Drive dan dimuat menggunakan `pandas.read_csv()`. Dataset ini berisi informasi tentang lagu-lagu terpopuler di dunia dari tahun 2010-2019, menurut data yang tersedia di Spotify dan diselaraskan dengan peringkat dari Billboard.

Pada tahap ini juga dilakukan eksplorasi awal terhadap data:
- Melihat jumlah baris dan kolom
- Melihat informasi struktur data
- Menampilkan contoh data
- Mengecek missing values dan duplikat
- Mengetahui distribusi lagu per tahun
- Mengetahui genre terpopuler
- Mengetahui korelasi antar fitur numerik
- Mengetahui distribusi fitur numerik
"""

# --- Load dan persiapan data ---
df = pd.read_csv("top10s.csv", encoding='ISO-8859-1')

# Jumlah baris dan kolom
print(f"Jumlah baris dan kolom: {df.shape}")

# Informasi struktur data
df.info()

df.head()

# Cek jumlah data duplikat (baris yang sama persis)
jumlah_duplikat = df.duplicated().sum()
print(f"Jumlah data duplikat: {jumlah_duplikat}")

# Jumlah nilai kosong per kolom
df.isnull().sum()

plt.figure(figsize=(10, 5))
sns.countplot(data=df, x='year', palette='coolwarm')
plt.title('Jumlah Lagu per Tahun')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""Visualisasi ini menunjukkan jumlah lagu populer yang tercatat dalam dataset berdasarkan tahun rilisnya. Dapat dilihat lagu populer terbanyak yang tercatat dalam dataset terdapat pada tahun 2015"""

plt.figure(figsize=(12, 6))
top_genres = df['top genre'].value_counts().head(10)
sns.barplot(x=top_genres.values, y=top_genres.index, palette='magma')
plt.title('10 Genre Terpopuler dalam Dataset')
plt.xlabel('Jumlah Lagu')
plt.ylabel('Genre')
plt.show()

"""Barplot diatas menunjukkan 10 genre terpopuler berdasarkan frekuensi kemunculannya dalam dataset. Dapat dilihat genre ter-populer adalah dance pop"""

features = ['bpm', 'nrgy', 'dnce', 'val', 'dur', 'acous', 'spch', 'live']
plt.figure(figsize=(10, 8))
sns.heatmap(df[features].corr(), annot=True, cmap='YlGnBu')
plt.title('Korelasi antar fitur lagu')
plt.show()

"""Heatmap korelasi antar fitur lagu menunjukkan bahwa fitur-fitur seperti **bpm** dan **nrgy** memiliki hubungan positif, sementara **nrgy** dan **acous** menunjukkan korelasi negatif. Secara umum, fitur tidak terlalu berkorelasi kuat, sehingga semuanya layak digunakan dalam model.

## Data Preparation
"""

df = df.loc[:, ~df.columns.str.lower().str.contains("unnamed")]

df.head()

df.columns = df.columns.str.lower()

# Fitur numerik
features = ['bpm', 'nrgy', 'dnce', 'val', 'dur', 'acous', 'spch', 'live']
scaler = MinMaxScaler()
df_scaled = df.copy()
df_scaled[features] = scaler.fit_transform(df_scaled[features])

"""## Modeling"""

similarity_matrix = cosine_similarity(df_scaled[features])

"""### Fungsi-fungsi Rekomendasi"""

# Rekmondasi berdasarkan judul lagu
def recommend_by_title(song_title, df, similarity_matrix, top_n=10):
    idx = df[df['title'].str.lower() == song_title.lower()].index
    if len(idx) == 0:
        return f"Lagu '{song_title}' tidak ditemukan dalam dataset."
    idx = idx[0]
    sim_scores = list(enumerate(similarity_matrix[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    return df.iloc[[i[0] for i in sim_scores]][['title', 'artist', 'top genre']].reset_index(drop=True)

# Rekomendasi berdasarkan genre
def recommend_by_genre(genre, df, similarity_matrix, top_n=10):
    genre_df = df[df['top genre'].str.lower() == genre.lower()]
    if genre_df.empty:
        return f"Genre '{genre}' tidak ditemukan dalam dataset."
    idx = genre_df.index[0]
    sim_scores = list(enumerate(similarity_matrix[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
    return df.iloc[[i[0] for i in sim_scores]][['title', 'artist', 'top genre']].reset_index(drop=True)

# Rekomendasi berdasarkan artis
def recommend_by_artist(artist, df, similarity_matrix, top_n=10):
    artist_df = df[df['artist'].str.lower() == artist.lower()]
    if artist_df.empty:
        return f"Artis '{artist}' tidak ditemukan dalam dataset."
    idx_list = artist_df.index.tolist()
    avg_similarity = similarity_matrix[idx_list].mean(axis=0)
    sim_scores = list(enumerate(avg_similarity))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = [s for s in sim_scores if s[0] not in idx_list][:top_n]
    return df.iloc[[i[0] for i in sim_scores]][['title', 'artist', 'top genre']].reset_index(drop=True)

"""### Interface menggunakan ipywidget"""

# Dropdown mode rekomendasi
mode_dropdown = widgets.Dropdown(
    options=['Judul Lagu', 'Genre', 'Artis'],
    description='Mode Rekomendasi:',
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='60%')
)

# Dropdown input (judul, genre, artis)
input_dropdown = widgets.Dropdown(
    options=[],  # Akan diisi berdasarkan mode
    description='Input:',
    style={'description_width': 'initial'},
    layout=widgets.Layout(width='60%')
)

# Tombol & output
recommend_button = widgets.Button(description="Rekomendasikan")
output = widgets.Output()

# Update input sesuai mode
def update_input_options(change):
    mode = change['new']
    if mode == 'Judul Lagu':
        input_dropdown.options = sorted(df['title'].unique().tolist())
    elif mode == 'Genre':
        input_dropdown.options = sorted(df['top genre'].unique().tolist())
    elif mode == 'Artis':
        input_dropdown.options = sorted(df['artist'].unique().tolist())

mode_dropdown.observe(update_input_options, names='value')
update_input_options({'new': mode_dropdown.value})  # Set awal

# Fungsi tombol klik
def on_button_clicked(b):
    with output:
        output.clear_output()
        mode = mode_dropdown.value
        input_value = input_dropdown.value

        if mode == 'Judul Lagu':
            display(recommend_by_title(input_value, df, similarity_matrix))
        elif mode == 'Genre':
            display(recommend_by_genre(input_value, df, similarity_matrix))
        elif mode == 'Artis':
            display(recommend_by_artist(input_value, df, similarity_matrix))

recommend_button.on_click(on_button_clicked)

# Tampilkan semua widget
display(mode_dropdown, input_dropdown, recommend_button, output)

"""## Evaluasi"""

def evaluate_precision_by_artist(df, similarity_matrix, top_n=10, sample_size=20):
    results = []
    sample_indices = np.random.choice(len(df), size=sample_size, replace=False)

    for idx in sample_indices:
        input_artist = df.iloc[idx]['artist']
        sim_scores = list(enumerate(similarity_matrix[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
        recommended_artists = [df.iloc[i[0]]['artist'] for i in sim_scores]

        precision = sum([1 for artist in recommended_artists if artist == input_artist]) / top_n
        results.append({
            'title': df.iloc[idx]['title'],
            'true_artist': input_artist,
            'precision': precision
        })

    result_df = pd.DataFrame(results)
    avg_precision = result_df['precision'].mean()
    return avg_precision, result_df

avg_precision, precision_details = evaluate_precision_by_artist(df, similarity_matrix, top_n=10, sample_size=20)
print(f"Rata-rata Precision@10 berdasarkan artis: {avg_precision:.2f}")
precision_details.head()

"""Rekomendasi dari artis yang sama relatif lebih sedikit. Ini menunjukkan bahwa model lebih menekankan kesamaan fitur numerik dibanding mengelompokkan berdasarkan artis."""

import numpy as np
import pandas as pd

def evaluate_precision_by_genre(df, similarity_matrix, top_n=10, sample_size=20):
    results = []
    sample_indices = np.random.choice(len(df), size=sample_size, replace=False)

    for idx in sample_indices:
        input_genre = df.iloc[idx]['top genre']
        sim_scores = list(enumerate(similarity_matrix[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
        recommended_genres = [df.iloc[i[0]]['top genre'] for i in sim_scores]

        precision = sum([1 for genre in recommended_genres if genre == input_genre]) / top_n
        results.append({
            'title': df.iloc[idx]['title'],
            'artist': df.iloc[idx]['artist'],
            'true_genre': input_genre,
            'precision': precision
        })

    result_df = pd.DataFrame(results)
    avg_precision = result_df['precision'].mean()
    return avg_precision, result_df

# Jalankan di notebook
avg_precision, precision_details = evaluate_precision_by_genre(df, similarity_matrix, top_n=10, sample_size=20)
print(f"Rata-rata Precision@10 berdasarkan genre: {avg_precision:.2f}")
precision_details.head()

"""Sistem cukup baik dalam mengelompokkan lagu berdasarkan genre. Hal ini menunjukkan bahwa fitur numerik seperti `bpm`, `val`, dan `nrgy` dapat menangkap karakteristik umum dari genre yang sama."""

def evaluate_precision_by_bpm(df, similarity_matrix, top_n=10, sample_size=20, bpm_threshold=5):
    results = []
    sample_indices = np.random.choice(len(df), size=sample_size, replace=False)

    for idx in sample_indices:
        input_bpm = df.iloc[idx]['bpm']
        sim_scores = list(enumerate(similarity_matrix[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n+1]
        recommended_bpms = [df.iloc[i[0]]['bpm'] for i in sim_scores]

        precision = sum([1 for bpm in recommended_bpms if abs(bpm - input_bpm) <= bpm_threshold]) / top_n
        results.append({
            'title': df.iloc[idx]['title'],
            'true_bpm': input_bpm,
            'precision': precision
        })

    result_df = pd.DataFrame(results)
    avg_precision = result_df['precision'].mean()
    return avg_precision, result_df

avg_bpm_prec, bpm_prec_details = evaluate_precision_by_bpm(df, similarity_matrix)
print(f"Precision by BPM (Â±5): {avg_bpm_prec:.2f}")
precision_details.head()

"""Sekitar 33% rekomendasi memiliki tempo yang sangat mirip. Ini menunjukkan bahwa meskipun BPM merupakan salah satu fitur yang digunakan, fitur lain seperti dnce (danceability) dan nrgy (energi) kemungkinan memberikan pengaruh lebih besar terhadap kemiripan yang dihitung oleh model."""
